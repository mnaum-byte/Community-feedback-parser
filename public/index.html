<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%234f8cff'/%3E%3C/svg%3E" />
    <title>UserVoice feedback extractor for Adobe Express</title>
    <style>
        :root {
            --bg: #0b0d10;
            --panel: #12151a;
            --muted: #8a93a6;
            --text: #e4e7ec;
            --border: #242a34;
            --accent: #4f8cff;
            --danger: #ff5c79;
            --why-bg: #1b2230;
            --why-border: #2a3750;
            --why-must: #8fd19e;
            --why-optional: #8fb5ff;
            --why-exclude: #ff9aa6;
            --why-prox: #ffd37a;
            --why-sem: #b58cff;
        }
        *, *::before, *::after { box-sizing: border-box; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; color: var(--text); background: radial-gradient(1200px 800px at 50% -20%, #141924 0%, var(--bg) 50%); }
        .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
        h1 { font-size: 22px; margin: 0 0 8px 0; display:flex; gap:8px; align-items: baseline; justify-content: space-between; }
        h2 { font-size: 16px; margin: 0 0 10px 0; color: var(--muted); display:flex; align-items:center; gap:8px; }
        .subtitle { color: var(--muted); font-size: 13px; margin-bottom: 8px; }
        .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; display: flex; flex-direction: column; }
        .row { display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; }
        .row-col { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; }
        .row-col > div { min-width: 0; }
        label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
        input, textarea { width: 100%; max-width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; color: var(--text); background: #0f1319; display: block; }
        textarea { min-height: 72px; }
        button { padding: 10px 14px; border-radius: 8px; border: 1px solid var(--accent); background: var(--accent); color: #fff; cursor: pointer; }
        button.secondary { background: transparent; color: var(--text); border: 1px solid var(--border); }
        .hint { font-size: 12px; color: var(--muted); }
        .section { margin: 0; }
        table { border-collapse: separate; border-spacing: 0; width: 100%; margin-top: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; table-layout: fixed; }
        th, td { border-bottom: 1px solid var(--border); text-align: left; padding: 10px; font-size: 14px; vertical-align: top; word-break: break-word; overflow-wrap: anywhere; }
        thead th { position: sticky; top: 0; background: #141923; z-index: 1; }
        td a { color: #8fb5ff; text-decoration: none; word-break: break-word; overflow-wrap: anywhere; }
        td a:hover { text-decoration: underline; }
        th { color: var(--muted); font-weight: 600; background: #141923; }
        .status { margin-top: 10px; font-size: 13px; color: var(--muted); }
        .status.error { color: var(--danger); }
        .loader { display: none; margin-left: 8px; }
        .progress { font-size: 12px; color: var(--muted); }
        .controls { display: flex; gap: 12px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
        .controls label { display: inline; margin: 0 6px 0 0; }
        .badge { padding: 2px 8px; border-radius: 999px; border:1px solid var(--border); font-size: 12px; color: var(--muted); }
        .badge.ok { color: #6de39b; border-color: #1f3a2b; background: #0e1f16; }
        .note { font-size: 12px; color: var(--muted); }
        .footerbar { position: fixed; left: 0; right: 0; bottom: 0; background: #0f1319; border-top: 1px solid var(--border); }
        .footer-inner { display: grid; grid-template-columns: 1fr 1fr 1fr; align-items: center; gap: 16px; padding-top: 12px; padding-bottom: 12px; }
        .footer-col.left { justify-self: start; display: flex; gap: 8px; align-items: center; }
        .footer-col.center { justify-self: center; }
        .footer-col.right { justify-self: end; display: flex; gap: 8px; align-items: center; }
        .chip { font-size: 12px; padding: 2px 8px; border-radius: 999px; border:1px solid var(--border); color: var(--muted); }
        .chip.prod { color:#6de39b; border-color:#1f3a2b; background:#0e1f16; }
        .grid-3 { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 16px; }
        .toggle { display:inline-flex; align-items:center; gap:8px; font-size: 13px; color: var(--text); }
        .switch { position: relative; width: 36px; height: 22px; background: #1b2230; border:1px solid var(--border); border-radius: 999px; cursor: pointer; transition: background .2s ease; }
        .switch::after { content: ""; position: absolute; top: 50%; left: 3px; transform: translateY(-50%); width: 16px; height: 16px; background: #8892a6; border-radius: 50%; transition: left .2s ease, background .2s ease; }
        .switch.on { background: #183055; border-color: #2a4f8e; }
        .switch.on::after { left: 17px; background: #4f8cff; }
        .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
        .panel-footer { display:flex; justify-content:flex-end; align-items:center; margin-top: auto; padding-top: 12px; gap: 8px; }
        .panel-footer.column-footer { flex-direction: column; align-items: flex-end; }
        .panel-footer.column-footer { align-items: flex-start; }
        .panel-footer.column-footer .toolbar { justify-content: flex-start; }
        /* New layout */
        .app { display:flex; flex-direction: column; gap: 24px; align-items: stretch; }
        .sidebar { flex: 0 0 auto; max-width: 100%; position: static; top: auto; height: auto; }
        .sidebar .panel > div:not(.panel-footer) { margin-top: 18px; }
        .content { flex: 0 0 auto; max-width: 100%; display: flex; flex-direction: column; gap: 24px; align-items: stretch; }
        .content > .section.panel { width: 100%; flex: 0 0 auto; margin: 0; }
        .section.panel table { width: 100%; }
        .toolbar { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
        .ghost { opacity: .6; pointer-events: none; }
        .sr-announcer { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
        /* Why chips */
        .why { display:flex; flex-wrap: wrap; gap:6px; }
        .why .chip { border-color: var(--why-border); background: var(--why-bg); color: var(--muted); }
        .why .chip.must { color: var(--why-must); border-color: rgba(111, 199, 141, .2); }
        .why .chip.optional { color: var(--why-optional); border-color: rgba(143, 181, 255, .2); }
        .why .chip.exclude { color: var(--why-exclude); border-color: rgba(255, 154, 166, .2); }
        .why .chip.prox { color: var(--why-prox); border-color: rgba(255, 211, 122, .2); }
        .why .chip.sem { color: var(--why-sem); border-color: rgba(181, 140, 255, .2); }
        /* Mobile sidebar toggle */
        .sidebar-toggle { display:none; }
        @media (max-width: 900px) {
          .app { flex-direction: column; }
          .sidebar, .content { max-width: 100%; flex-basis: auto; position: static; }
          .sidebar { display: none; }
          body.show-sidebar .sidebar { display: block; }
          .sidebar-toggle { display:inline-flex; }
        }
        /* Hide filters panel in sidebar until opened in modal */
        #filters-section { display: none !important; }
        /* Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.6); display: none; align-items: center; justify-content: center; z-index: 1000; pointer-events: none; }
        .modal-overlay.open { display: flex; pointer-events: auto; }
        .modal-overlay[hidden] { display: none !important; }
        .modal { position: relative; background: var(--panel); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); display: flex; flex-direction: column; max-width: 90%; max-height: 90%; overflow: hidden; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { margin: 0; }
        .modal-body { flex: 1; overflow-y: auto; padding: 16px; }
        .modal-footer { display:flex; justify-content:flex-end; gap:8px; padding: 10px 16px; border-top: 1px solid var(--border); }
        .modal.compact { width: min(720px, 92vw); height: auto; max-height: 80vh; }
        .modal.compact .modal-body { flex: 0 0 auto; padding: 16px; }
    </style>
 </head>
 <body>
   <div class="container">
   <h1>UserVoice feedback extractor for Adobe Express
   </h1>
 
   <div class="app">
     <aside class="sidebar" id="sidebar-panel">
       <div id="filters-section" class="panel filters">
         <div>
           <label>Optional keywords (comma separated)</label>
           <input id="optionalKeywords" placeholder="e.g. pdf, export, caption" />
           <div class="hint">Any of these helps (broad)</div>
         </div>
         <div style="margin-top:12px;">
           <label>Must-have keywords (comma separated)</label>
           <input id="mustKeywords" placeholder="e.g. brand kit, styles, logo" />
           <div class="hint">All of these should be present (strict)</div>
         </div>
         <div style="margin-top:12px;">
           <label>Excluded keywords (comma separated)</label>
           <input id="excludeKeywords" placeholder="e.g. animation, video" />
           <div class="hint">Items containing any will be excluded</div>
         </div>
         <div style="margin-top:8px;">
           <label class="toggle" title="Adds domain synonyms (e.g., 'brand kit' → 'brand assets'). Increases recall."><span class="switch" id="toggle-syn"></span><span>Expand with synonyms</span><input class="sr-only" type="checkbox" id="useSynonyms" checked /></label>
         </div>
         <div style="margin-top:12px;">
           <label title="Describe the functionality/flow you care about. Helps semantic matching.">Feature definition (1-3 sentences)</label>
           <textarea id="featureDef" placeholder="Describe the functionality/flow you care about..."></textarea>
           <div class="hint">Used for semantic matching</div>
         </div>
         <div style="margin-top:8px;">
           <label class="toggle" title="Uses embeddings to find semantically similar content; slower but more precise."><span class="switch" id="toggle-sem"></span><span>Use semantic matching</span><input class="sr-only" type="checkbox" id="useSemantic" /></label>
         </div>
         <div class="toolbar" style="justify-content: space-between; margin-top: 10px;">
           <span id="last-run" class="hint"></span>
         </div>
       </div>
       <div class="toolbar" style="justify-content:flex-start; margin: 8px 0 0 0;">
         <button id="btn-configure-filters">Configure search filters</button>
       </div>
       <div class="extract-controls" style="display:flex; flex-direction:column; gap:8px; margin: 10px 0 0 0;">
         <div class="toolbar" style="justify-content:flex-start;">
           <button id="btn-parse">Extract Relevant Threads</button>
           <span id="parse-progress" class="progress"></span>
           <span id="parse-status" class="status"></span>
           <span id="parse-loader" class="loader">⏳</span>
         </div>
         <div class="toolbar" style="justify-content:flex-start;">
           <button id="btn-extract">Extract User Comments</button>
           <span id="comments-progress" class="progress"></span>
           <span id="comments-status" class="status"></span>
           <span id="comments-loader" class="loader">⏳</span>
         </div>
       </div>
     </aside>

     <main class="content" style="display:none;">
       <div id="threads-section" class="section panel">
         <div class="toolbar" style="justify-content: space-between;">
           <h2>Relevant Threads <span id="selected-count" class="hint"></span></h2>
           <div class="toolbar">
             <button id="btn-export-threads-csv" class="secondary">Export CSV</button>
             <button id="btn-export-threads-xlsx" class="secondary">Export XLSX</button>
           </div>
         </div>
         <table>
           <thead>
             <tr><th><input id="select-all" type="checkbox"/></th><th>#</th><th>Title</th><th>URL</th><th>Why</th></tr>
           </thead>
           <tbody id="threads-body" aria-live="polite"><tr id="threads-empty"><td colspan="5" class="hint">No threads yet. Run “Extract Relevant Threads”.</td></tr></tbody>
         </table>
       </div>
 
       <div id="comments-section" class="section panel">
         <div class="toolbar" style="justify-content: space-between;">
           <h2>User comments</h2>
           <div class="toolbar">
             <button id="btn-export-comments-csv" class="secondary">Export CSV</button>
             <button id="btn-export-comments-xlsx" class="secondary">Export XLSX</button>
           </div>
         </div>
         <table>
           <thead>
            <tr><th><input id="select-all-comments" type="checkbox"/></th><th>#</th><th>Title</th><th>URL</th><th>Why</th></tr>
           </thead>
          <tbody id="comments-body" aria-live="polite"><tr id="comments-empty"><td colspan="5" class="hint">No comments yet. Use “Extract User Comments”.</td></tr></tbody>
         </table>
       </div>
     </main>
     <div id="modal-overlay" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true" hidden>
       <div class="modal" id="modal-root" role="document">
         <div class="modal-header">
           <h2 id="modal-title" style="margin:0;">Results</h2>
           <div class="toolbar" id="modal-progress-wrap">
             <span id="modal-progress" class="progress"></span>
             <span id="modal-status" class="status"></span>
             <span id="modal-loader" class="loader">⏳</span>
           </div>
           <button id="modal-close" class="modal-close">Close</button>
         </div>
         <div id="modal-body" class="modal-body"></div>
         <div id="modal-footer" class="modal-footer" style="display:none;">
           <span id="filters-error" class="status error" style="min-height:18px;"></span>
           <button id="btn-save-filters">Save</button>
         </div>
       </div>
     </div>
   </div>

   <div class="footerbar">
     <div class="container footer-inner">
       <div class="footer-col left">
         <span style="color: var(--muted); font-size: 13px;">Sign in status</span>
         <span id="auth-status" class="badge">Checking auth...</span>
       </div>
       <div class="footer-col center">
         <a href="https://adobeexpress.uservoice.com/forums/951181-adobe-express" target="_blank" rel="noopener">Adobe Express Uservoice Forum</a>
       </div>
       <div class="footer-col right">
         <span id="env-chip" class="chip">env</span>
         <span id="backend-chip" class="chip">backend</span>
         <a id="logs-link" class="chip" href="#" target="_blank" rel="noopener" style="display:none;">Logs</a>
       </div>
     </div>
   </div>

   <div id="sr-announce" class="sr-announcer" aria-live="polite"></div>

   <script>
     const el = (id) => document.getElementById(id);
     let relevantThreads = [];
     let selectedThreads = new Set();
     let threadRowCount = 0;
     let commentRowCount = 0;
     let isAuthed = false;
     let sseParse = null;
     let sseComments = null;
     let parseJobState = 'idle'; // idle | running | completed | error
     let parseLastKey = '';
     let commentsJobState = 'idle'; // idle | running | completed | error
     let commentsLastKey = '';

     // Production chip and backend info
     (function setEnvChips(){
       const isProd = window.location.hostname !== 'localhost';
       const envChip = el('env-chip');
       const backendChip = el('backend-chip');
       const logsLink = el('logs-link');
       envChip.textContent = isProd ? 'production' : 'local';
       if (isProd) envChip.className = 'chip prod';
       backendChip.textContent = window.location.origin;
       if (/onrender\.com$/.test(window.location.hostname)) {
         logsLink.href = window.location.origin + '/health';
         logsLink.style.display = 'inline-block';
         logsLink.textContent = 'Health';
       }
     })();

     async function refreshAuth() {
       try {
         const res = await fetch('/auth/status');
         const data = await res.json();
         const hasCookieAuth = !!data.authenticated;
         const hasOAuth = !!data.oauth;
         isAuthed = hasCookieAuth || hasOAuth;
         el('auth-status').textContent = hasCookieAuth ? 'Signed in' : (hasOAuth ? 'API auth' : 'Not signed in');
         el('auth-status').className = isAuthed ? 'badge ok' : 'badge';
       } catch (_) {
         el('auth-status').textContent = 'Unknown';
         el('auth-status').className = 'badge';
       }
     }

     function csvToArray(value) {
       return (value || '').split(',').map(s => s.trim()).filter(Boolean);
     }

     function loadFilters() {
       try {
         const raw = localStorage.getItem('uv_filters');
         if (!raw) return;
         const f = JSON.parse(raw);
         if (f.optional != null) el('optionalKeywords').value = f.optional;
         if (f.must != null) el('mustKeywords').value = f.must;
         if (f.exclude != null) el('excludeKeywords').value = f.exclude;
         if (f.featureDef != null) el('featureDef').value = f.featureDef;
         if (f.useSynonyms != null) el('useSynonyms').checked = !!f.useSynonyms;
         if (f.useSemantic != null) el('useSemantic').checked = !!f.useSemantic;
       } catch (_) {}
     }

     function saveFilters() {
       const payload = {
         optional: el('optionalKeywords').value,
         must: el('mustKeywords').value,
         exclude: el('excludeKeywords').value,
         featureDef: el('featureDef').value,
         useSynonyms: el('useSynonyms').checked,
         useSemantic: el('useSemantic').checked,
       };
       localStorage.setItem('uv_filters', JSON.stringify(payload));
     }

     function buildQueryPayload() {
       return {
         cookie: '',
         query: {
           must: csvToArray(el('mustKeywords').value),
           optional: csvToArray(el('optionalKeywords').value),
           exclude: csvToArray(el('excludeKeywords').value),
           featureDef: el('featureDef').value.trim(),
           useSynonyms: el('useSynonyms').checked,
           useSemantic: el('useSemantic').checked
         }
       };
     }

     function computeKey(obj) { try { return JSON.stringify(obj); } catch(_) { return String(obj); } }

     function announce(msg) { const n = document.getElementById('sr-announce'); if (n) n.textContent = msg; }

     // Modal refs and helpers
     const modalOverlay = el('modal-overlay');
     const modalRoot = el('modal-root');
     const modalTitle = el('modal-title');
     const modalBody = el('modal-body');
     const modalFooter = el('modal-footer');
     const modalClose = el('modal-close');
     let modalCurrent = null; // 'threads' | 'comments' | 'filters' | null

     function openModalWith(sectionId, title) {
       const section = document.getElementById(sectionId);
       if (!section) return;
       modalTitle.textContent = title;
       if (sectionId === 'filters-section') {
         modalCurrent = 'filters';
         if (modalRoot) modalRoot.classList.add('compact');
         if (modalFooter) modalFooter.style.display = 'flex';
         modalBody.innerHTML = '';
         Array.from(section.children).forEach(child => { child.style.display = ''; modalBody.appendChild(child); });
         const ferr = document.getElementById('filters-error'); if (ferr) ferr.textContent = '';
       } else {
         modalCurrent = sectionId === 'threads-section' ? 'threads' : 'comments';
         if (modalRoot) modalRoot.classList.remove('compact');
         if (modalFooter) modalFooter.style.display = 'none';
         modalBody.innerHTML = '';
         modalBody.appendChild(section);
       }
       modalOverlay.removeAttribute('hidden');
       modalOverlay.classList.add('open');
       modalOverlay.setAttribute('aria-hidden', 'false');
     }

     function closeModal() {
       const content = document.querySelector('main.content');
       const sidebar = document.getElementById('sidebar-panel');
       const threadsSec = document.getElementById('threads-section');
       const commentsSec = document.getElementById('comments-section');
       const filtersSec = document.getElementById('filters-section');
       if (content && threadsSec && !content.contains(threadsSec)) content.appendChild(threadsSec);
       if (content && commentsSec && !content.contains(commentsSec)) content.appendChild(commentsSec);
       if (sidebar && filtersSec && modalCurrent === 'filters') {
        while (modalBody.firstChild) filtersSec.appendChild(modalBody.firstChild);
        filtersSec.style.display = 'none';
       }
       modalOverlay.classList.remove('open');
       modalOverlay.setAttribute('aria-hidden', 'true');
       modalOverlay.setAttribute('hidden', '');
       modalCurrent = null;
     }
     if (modalClose) modalClose.addEventListener('click', closeModal);
     modalOverlay?.addEventListener('click', (e)=>{ if (e.target === modalOverlay) closeModal(); });

     function clearThreads() {
       el('threads-body').innerHTML = '<tr id="threads-empty"><td colspan="5" class="hint">No threads yet. Run “Extract Relevant Threads”.</td></tr>';
       relevantThreads = []; selectedThreads.clear(); threadRowCount = 0;
     }

     function clearComments() {
       el('comments-body').innerHTML = '<tr id="comments-empty"><td colspan="5" class="hint">No comments yet. Use “Extract User Comments”.</td></tr>';
       commentRowCount = 0;
     }

     function renderThread(row) {
       const empty = el('threads-empty'); if (empty) empty.remove();
       const tr = document.createElement('tr');
       tr.dataset.threadUrl = row.url;
       const tdSel = document.createElement('td');
       const cb = document.createElement('input'); cb.type = 'checkbox'; cb.addEventListener('change', () => {
         if (cb.checked) selectedThreads.add(row.url); else selectedThreads.delete(row.url);
         updateSelectionUI();
       });
       tdSel.appendChild(cb);
       const tdIdx = document.createElement('td');
       const tdTitle = document.createElement('td');
       const tdUrl = document.createElement('td');
       const tdWhy = document.createElement('td');
       tdIdx.textContent = String(++threadRowCount);
       tdTitle.textContent = row.title;
       const a = document.createElement('a');
       a.href = row.url; a.target = '_blank'; a.rel = 'noopener'; a.textContent = 'Thread URL';
       tdUrl.appendChild(a);
       tdWhy.appendChild(formatWhy(row._why));
       tr.appendChild(tdSel); tr.appendChild(tdIdx); tr.appendChild(tdTitle); tr.appendChild(tdUrl); tr.appendChild(tdWhy);
       el('threads-body').appendChild(tr);
       announce('Thread added: ' + row.title);
     }

     function updateSelectionUI() {
       const count = selectedThreads.size;
       const badge = document.getElementById('selected-count');
       if (badge) badge.textContent = count ? '(' + count + ' selected)' : '';
     }

     function markThreadNote(threadUrl, note) {
       const rows = el('threads-body').querySelectorAll('tr');
       for (const r of rows) {
         if (r.dataset.threadUrl === threadUrl) {
           let cell = r.querySelector('td.note-cell');
           if (!cell) {
             cell = document.createElement('td');
             cell.className = 'note-cell';
             r.appendChild(cell);
           }
           cell.textContent = note;
           cell.className = 'note-cell note';
           break;
         }
       }
     }

     function renderComment(row) {
       const empty = el('comments-empty'); if (empty) empty.remove();
       const tr = document.createElement('tr');
       tr.dataset.threadUrl = row.threadUrl || row.url;
       const tdSel = document.createElement('td');
       const cb = document.createElement('input'); cb.type = 'checkbox';
       tdSel.appendChild(cb);
       const tdIdx = document.createElement('td');
       tdIdx.textContent = String(++commentRowCount);
       const tdTitle = document.createElement('td');
       tdTitle.textContent = row.body;
       const tdUrl = document.createElement('td');
       const a = document.createElement('a'); a.href = row.threadUrl || row.url; a.target = '_blank'; a.rel = 'noopener'; a.textContent = 'Thread URL'; tdUrl.appendChild(a);
       const tdWhy = document.createElement('td');
       tdWhy.appendChild(formatWhy(row._why));
       tr.appendChild(tdSel); tr.appendChild(tdIdx); tr.appendChild(tdTitle); tr.appendChild(tdUrl); tr.appendChild(tdWhy);
       el('comments-body').appendChild(tr);
       announce('Comment added');
     }

     function formatWhy(text) {
       const container = document.createElement('div');
       container.className = 'why';
       if (!text) return container;
       const tokens = String(text).split(/[;|,\n]+/).map(t=>t.trim()).filter(Boolean);
       tokens.forEach(tok => {
         const m = /^([^:]+):\s*(.+)$/.exec(tok);
         let label = '', value = '';
         if (m) { label = m[1].toLowerCase(); value = m[2]; } else { value = tok; }
         const span = document.createElement('span');
         span.className = 'chip';
         if (/must/.test(label)) span.classList.add('must');
         else if (/optional|syn/.test(label)) span.classList.add('optional');
         else if (/exclude|not/.test(label)) span.classList.add('exclude');
         else if (/prox|near|distance/.test(label)) span.classList.add('prox');
         else if (/sem|embedding|cosine|score/.test(label)) span.classList.add('sem');
         span.textContent = m ? `${label}: ${value}` : value;
         container.appendChild(span);
       });
       return container;
     }

     function setLastRun(kind, info) {
       const t = new Date().toLocaleTimeString();
       el('last-run').textContent = (kind === 'threads') ? `Last threads run: ${t} (${info})` : `Last comments run: ${t} (${info})`;
     }

     async function startParse() {
       const payload = buildQueryPayload();
       const currentKey = computeKey(payload.query);
       // If same query and job already running or completed, just reopen the modal
       if ((parseJobState === 'running' || parseJobState === 'completed') && parseLastKey === currentKey) {
         modalCurrent = 'threads';
         openModalWith('threads-section', 'Relevant Threads');
         return;
       }
       if (!isAuthed) { el('parse-status').textContent = 'Please sign in'; el('parse-status').className = 'status error'; return; }
       const hasAny = (payload.query.must.length + payload.query.optional.length) > 0 || payload.query.featureDef.length > 0;
       if (!hasAny) { el('parse-status').textContent = 'Provide at least one keyword or a feature definition'; el('parse-status').className = 'status error'; return; }
       // Starting a new job: clear previous results now
       clearThreads();
       // Reset statuses/progress only for new job
       el('parse-status').textContent = '';
       el('parse-progress').textContent = '';
       if (modalStatus) modalStatus.textContent = '';
       if (modalProgress) modalProgress.textContent = '';
       modalCurrent = 'threads';
       openModalWith('threads-section', 'Relevant Threads');
       el('parse-loader').style.display = 'inline';
       if (modalLoader) modalLoader.style.display = 'inline';
       try {
         parseJobState = 'running';
         parseLastKey = currentKey;
         const res = await fetch('/api/parse/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
         const { jobId, error } = await res.json();
         if (!res.ok) throw new Error(error || 'Failed to start parse job');
         if (sseParse) { try { sseParse.close(); } catch(_){} }
         sseParse = new EventSource(`/api/parse/events/${jobId}`);
         sseParse.addEventListener('connected', () => { el('parse-status').textContent = 'Connected'; el('parse-status').className = 'status'; });
         sseParse.addEventListener('thread', (ev) => { const row = JSON.parse(ev.data); relevantThreads.push(row); renderThread(row); updateSelectionUI(); });
         sseParse.addEventListener('progress', (ev) => {
           const p = JSON.parse(ev.data);
           if (p.phase === 'discover') {
             el('parse-progress').textContent = `Pages discovered: ${p.discoveredPages || p.pageIndex}`;
             if (modalCurrent === 'threads' && modalProgress) modalProgress.textContent = el('parse-progress').textContent;
             return;
           }
           const scanned = p.scannedThreads || 0; const total = p.totalThreads || 0; const rel = p.totalRelevant || 0;
           el('parse-progress').textContent = `Threads scanned: ${scanned}/${total} | Relevant: ${rel}`;
           if (modalCurrent === 'threads' && modalProgress) modalProgress.textContent = el('parse-progress').textContent;
         });
         sseParse.addEventListener('error', (ev) => { const msg = JSON.parse(ev.data).message; parseJobState = 'error'; el('parse-status').textContent = msg; el('parse-status').className = 'status error'; if (modalCurrent === 'threads' && modalStatus) modalStatus.textContent = msg; sseParse.close(); el('parse-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; });
         sseParse.addEventListener('done', () => { parseJobState = 'completed'; el('parse-status').textContent = 'Completed'; el('parse-status').className = 'status'; if (modalCurrent === 'threads' && modalStatus) modalStatus.textContent = 'Completed'; sseParse.close(); el('parse-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; setLastRun('threads', `${relevantThreads.length} found`); });
       } catch (e) { el('parse-status').textContent = e.message; el('parse-status').className = 'status error'; el('parse-loader').style.display = 'none'; el('btn-stop-parse').classList.add('ghost'); }
     }

     async function startExtract() {
       const payload = buildQueryPayload();
       if (!isAuthed) { el('comments-status').textContent = 'Please sign in'; el('comments-status').className = 'status error'; return; }
       const threadsToUse = (selectedThreads.size ? relevantThreads.filter(t => selectedThreads.has(t.url)) : relevantThreads);
       const commentsKey = computeKey({ query: payload.query, threads: threadsToUse.map(t => t.id || t.url) });
       if ((commentsJobState === 'running' || commentsJobState === 'completed') && commentsLastKey === commentsKey) {
         modalCurrent = 'comments';
         openModalWith('comments-section', 'User comments');
         return;
       }
       if (threadsToUse.length === 0) { el('comments-status').textContent = 'Select threads or run extraction first'; el('comments-status').className = 'status error'; return; }
       // Starting a new job: clear previous results now
       clearComments();
       // Reset statuses/progress only for new job
       el('comments-status').textContent = '';
       el('comments-progress').textContent = '';
       if (modalStatus) modalStatus.textContent = '';
       if (modalProgress) modalProgress.textContent = '';
       modalCurrent = 'comments';
       openModalWith('comments-section', 'User comments');
       el('comments-loader').style.display = 'inline';
       if (modalLoader) modalLoader.style.display = 'inline';
       try {
         commentsJobState = 'running';
         commentsLastKey = commentsKey;
         const res = await fetch('/api/comments/start', { 
           method: 'POST', 
           headers: { 'Content-Type': 'application/json' }, 
           body: JSON.stringify({ ...payload, threads: threadsToUse }) 
         });
         const { jobId, error } = await res.json();
         if (!res.ok) throw new Error(error || 'Failed to start comments job');
         if (sseComments) { try { sseComments.close(); } catch(_){} }
         sseComments = new EventSource(`/api/comments/events/${jobId}`);
         sseComments.addEventListener('connected', () => { 
           el('comments-status').textContent = 'Connected'; 
           el('comments-status').className = 'status'; 
           if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = 'Connected';
         });
         sseComments.addEventListener('comment', (ev) => { 
           const row = JSON.parse(ev.data); 
           renderComment(row); 
         });
         sseComments.addEventListener('threadNoComments', (ev) => { 
           const d = JSON.parse(ev.data); 
           markThreadNote(d.threadUrl, 'No comments'); 
         });
         sseComments.addEventListener('threadNoMatches', (ev) => { const d = JSON.parse(ev.data); markThreadNote(d.threadUrl, 'No matches'); });
         sseComments.addEventListener('progress', (ev) => { const p = JSON.parse(ev.data); const txt = `Threads processed: ${p.threadIndex || 0} | Relevant: ${p.totalRelevant || 0}`; el('comments-progress').textContent = txt; if (modalCurrent === 'comments' && modalProgress) modalProgress.textContent = txt; });
         sseComments.addEventListener('error', (ev) => { const msg = JSON.parse(ev.data).message; commentsJobState = 'error'; el('comments-status').textContent = msg; el('comments-status').className = 'status error'; if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = msg; sseComments.close(); el('comments-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; });
         sseComments.addEventListener('done', () => { commentsJobState = 'completed'; el('comments-status').textContent = 'Completed'; el('comments-status').className = 'status'; if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = 'Completed'; sseComments.close(); el('comments-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; setLastRun('comments', `${el('comments-body').children.length} added`); });
       } catch (e) { el('comments-status').textContent = e.message; el('comments-status').className = 'status error'; el('comments-loader').style.display = 'none'; el('btn-stop-comments').classList.add('ghost'); }
     }

     function stopComments() { if (sseComments) { try { sseComments.close(); } catch(_){} } el('comments-status').textContent = 'Stopped'; }

     // Exports
     let xlsxLoading = null;
     function loadScript(src) { return new Promise((resolve, reject) => { const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>resolve(); s.onerror=()=>reject(new Error('Failed to load '+src)); document.head.appendChild(s); }); }
     async function ensureXLSX() {
       if (window.XLSX) return;
       if (!xlsxLoading) {
         // Prefer local vendor route, then CDNs
         const fallbacks = [
           '/vendor/xlsx.full.min.js',
           'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js',
           'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
           'https://cdn.sheetjs.com/xlsx-0.18.5/package/dist/xlsx.full.min.js'
         ];
         xlsxLoading = (async () => {
           for (const url of fallbacks) {
             try { await loadScript(url); if (window.XLSX) return; } catch(_) {}
           }
           if (!window.XLSX) throw new Error('XLSX library failed to load');
         })();
       }
       return xlsxLoading;
     }
     function exportThreadsCSV() {
       if (!relevantThreads.length) return;
       const rows = [['#','Title','URL','Why']];
       relevantThreads.forEach((t,i)=>rows.push([i+1,t.title,t.url,t._why||'']));
       downloadCSV(rows, 'threads.csv');
     }
     function exportCommentsCSV() {
       const rows = [['#','Title','URL','Why']];
       const trs = Array.from(el('comments-body').children);
       trs.forEach(tr=>{
         const tds = tr.querySelectorAll('td'); if (tds.length<5) return;
         const idx = tds[1].textContent || '';
         const title = tds[2].textContent || '';
         const linkEl = tds[3].querySelector('a');
         const url = linkEl ? linkEl.href : '';
         const why = tds[4].textContent || '';
         rows.push([idx, title, url, why]);
       });
       downloadCSV(rows, 'comments.csv');
     }
     function downloadCSV(rows, filename){
       const csv = rows.map(r=>r.map(v => '"'+String(v).replace(/"/g,'""')+'"').join(',')).join('\n');
       const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
       const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
     }
     async function exportThreadsXLSX(){
       if(!relevantThreads.length) return;
       try { await ensureXLSX(); } catch(e) { alert('Could not load XLSX export library.'); return; }
       const wb=XLSX.utils.book_new(); const data=[['#','Title','URL','Why']]; relevantThreads.forEach((t,i)=>data.push([i+1,t.title,t.url,t._why||''])); const ws=XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(wb,ws,'Threads'); XLSX.writeFile(wb,'threads.xlsx');
     }
     async function exportCommentsXLSX(){
       try { await ensureXLSX(); } catch(e) { alert('Could not load XLSX export library.'); return; }
       const wb=XLSX.utils.book_new(); const data=[['#','Title','URL','Why']]; const trs=Array.from(el('comments-body').children); trs.forEach(tr=>{const tds=tr.querySelectorAll('td'); if(tds.length<5)return; const idx=tds[1].textContent||''; const title=tds[2].textContent||''; const linkEl=tds[3].querySelector('a'); const url=linkEl?linkEl.href:''; const why=tds[4].textContent||''; data.push([idx,title,url,why]);}); const ws=XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(wb,ws,'Comments'); XLSX.writeFile(wb,'comments.xlsx');
     }

     // Ensure content min-height matches sidebar height
     function syncLayoutHeights() {
       const sidebar = document.querySelector('.sidebar');
       const content = document.querySelector('.content');
       if (sidebar && content) { content.style.minHeight = sidebar.offsetHeight + 'px'; }
     }
     window.addEventListener('load', syncLayoutHeights);
     window.addEventListener('resize', syncLayoutHeights);
     setTimeout(syncLayoutHeights, 0);

     // Events
     const synSwitch = document.getElementById('toggle-syn');
     const synInput = document.getElementById('useSynonyms');
     const semSwitch = document.getElementById('toggle-sem');
     const semInput = document.getElementById('useSemantic');
     if (synSwitch && synInput) bindToggle(synSwitch, synInput);
     if (semSwitch && semInput) bindToggle(semSwitch, semInput);

     function bindToggle(switchEl, inputEl) {
       const labelEl = inputEl.closest('label');
       const sync = () => {
         const on = !!inputEl.checked;
         switchEl.classList.toggle('on', on);
         switchEl.setAttribute('aria-checked', String(on));
         switchEl.setAttribute('role', 'switch');
         saveFilters();
       };
       const handleClick = (ev) => {
         ev.preventDefault();
         ev.stopPropagation();
         inputEl.checked = !inputEl.checked;
         inputEl.dispatchEvent(new Event('change', { bubbles: true }));
       };
       if (labelEl) labelEl.addEventListener('click', handleClick);
       switchEl.addEventListener('click', handleClick);
       inputEl.addEventListener('change', sync);
       sync();
     }

     // Save filters on input
     ['optionalKeywords','mustKeywords','excludeKeywords','featureDef'].forEach(id=>{
       const e = el(id); if (!e) return; e.addEventListener('input', () => saveFilters());
     });

     // Selection
     el('select-all').addEventListener('change', (ev)=>{
       const checked = ev.target.checked; const rows = el('threads-body').querySelectorAll('input[type="checkbox"]');
       rows.forEach(cb=>{ cb.checked = checked; const tr = cb.closest('tr'); if (!tr) return; const url = tr.dataset.threadUrl; if (checked) selectedThreads.add(url); else selectedThreads.delete(url); });
       updateSelectionUI();
     });
     const selAllComments = el('select-all-comments');
     if (selAllComments) {
       selAllComments.addEventListener('change', (ev)=>{
         const checked = ev.target.checked; const rows = el('comments-body').querySelectorAll('input[type="checkbox"]');
         rows.forEach(cb=>{ cb.checked = checked; });
       });
     }

     el('btn-parse').addEventListener('click', startParse);
     el('btn-extract').addEventListener('click', startExtract);
     el('btn-export-threads-csv').addEventListener('click', exportThreadsCSV);
     el('btn-export-threads-xlsx').addEventListener('click', exportThreadsXLSX);
     el('btn-export-comments-csv').addEventListener('click', exportCommentsCSV);
     el('btn-export-comments-xlsx').addEventListener('click', exportCommentsXLSX);
     // removed Reset filters button
     // removed sidebar toggle in single-column layout

     loadFilters();
     refreshAuth();

     const btnConfigureFilters = document.getElementById('btn-configure-filters');
     function openFiltersModal(){ openModalWith('filters-section', 'Configure search filters'); }
     // expose for any external callers
     window.openFiltersModal = openFiltersModal;
 
     const modalProgress = document.getElementById('modal-progress');
     const modalStatus = document.getElementById('modal-status');
     const modalLoader = document.getElementById('modal-loader');
     // ensure globals exist to prevent ReferenceError in handlers
     window.modalProgress = modalProgress;
     window.modalStatus = modalStatus;
     window.modalLoader = modalLoader;

    const btnSaveFilters = document.getElementById('btn-save-filters');
    const filtersErrorEl = document.getElementById('filters-error');
    if (btnSaveFilters) btnSaveFilters.addEventListener('click', (e) => {
      e.preventDefault();
      const opt = (el('optionalKeywords').value || '').trim();
      const must = (el('mustKeywords').value || '').trim();
      const exc = (el('excludeKeywords').value || '').trim();
      const feat = (el('featureDef').value || '').trim();
      const hasAny = !!(opt || must || exc || feat);
      if (!hasAny) {
        if (filtersErrorEl) { filtersErrorEl.textContent = 'Provide at least one keyword or a feature definition'; }
        return;
      }
      try { saveFilters(); } catch(_) {}
      if (filtersErrorEl) { filtersErrorEl.textContent = ''; }
      closeModal();
    });
    // Save on Enter key in any filters input while filters modal is open
    const modalBodyEl = document.getElementById('modal-body');
    if (modalBodyEl) modalBodyEl.addEventListener('keydown', (e) => {
      if (modalCurrent === 'filters' && e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
        e.preventDefault();
        btnSaveFilters?.click();
      }
    });
 
     if (btnConfigureFilters) btnConfigureFilters.addEventListener('click', openFiltersModal);
   </script>
 </body>
</html>

