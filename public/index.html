<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%234f8cff'/%3E%3C/svg%3E" />
    <title>UserVoice feedback extractor for Adobe Express</title>
    <style>
        :root {
            --bg: #0b0d10;
            --panel: #12151a;
            --muted: #8a93a6;
            --text: #e4e7ec;
            --border: #242a34;
            --accent: #4f8cff;
            --danger: #ff5c79;
            --why-bg: #1b2230;
            --why-border: #2a3750;
            --why-must: #8fd19e;
            --why-optional: #8fb5ff;
            --why-exclude: #ff9aa6;
            --why-prox: #ffd37a;
            --why-sem: #b58cff;
            /* Material 3 tokens (minimal) */
            color-scheme: dark;
            --md-sys-color-primary: #4f8cff;
            --md-sys-color-on-primary: #ffffff;
            --md-sys-color-surface: #12151a;
            --md-sys-color-on-surface: #e4e7ec;
            --md-sys-color-surface-container-lowest: #0b0d10;
            --md-sys-color-surface-container-low: #101318;
            --md-sys-color-surface-container: #12151a;
            --md-sys-color-surface-container-high: #12151a;
            --md-sys-color-surface-container-highest: #12151a;
            --md-sys-color-on-surface-variant: #8a93a6;
            --md-sys-color-outline: #242a34;
        }
        *, *::before, *::after { box-sizing: border-box; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; color: var(--text); background: radial-gradient(1200px 800px at 50% -20%, #141924 0%, var(--bg) 50%); }
        .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
        h1 { font-size: 22px; margin: 0 0 8px 0; display:flex; gap:8px; align-items: baseline; justify-content: space-between; }
        h2 { font-size: 16px; margin: 0 0 10px 0; color: var(--muted); display:flex; align-items:center; gap:8px; }
        .subtitle { color: var(--muted); font-size: 13px; margin-bottom: 8px; }
        .intro { color: var(--muted); font-size: 14px; margin: 6px 0 14px; }
        .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; display: flex; flex-direction: column; }
        .row { display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; }
        .row-col { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; }
        .row-col > div { min-width: 0; }
        label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
        input, textarea { width: 100%; max-width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 8px; color: var(--text); background: #0f1319; display: block; }
        textarea { min-height: 72px; }
        button { padding: 10px 14px; border-radius: 8px; border: 1px solid var(--accent); background: var(--accent); color: #fff; cursor: pointer; }
        button.secondary { background: transparent; color: var(--text); border: 1px solid var(--border); }
        button:disabled { opacity: .6; cursor: not-allowed; }
        .hint { font-size: 12px; color: var(--muted); }
        .section { margin: 0; }
        table { border-collapse: separate; border-spacing: 0; width: 100%; margin-top: 10px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; table-layout: fixed; }
        th, td { border-bottom: 1px solid var(--border); text-align: left; padding: 10px; font-size: 14px; vertical-align: top; word-break: break-word; overflow-wrap: anywhere; }
        thead th { position: sticky; top: 0; background: #141923; z-index: 1; }
        td a { color: #8fb5ff; text-decoration: none; word-break: break-word; overflow-wrap: anywhere; }
        td a:hover { text-decoration: underline; }
        th { color: var(--muted); font-weight: 600; background: #141923; }
        .status { margin-top: 10px; font-size: 13px; color: var(--muted); }
        .status.error { color: var(--danger); }
        .loader { display: none; margin-left: 8px; }
        .progress { font-size: 12px; color: var(--muted); }
        .controls { display: flex; gap: 12px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
        .controls label { display: inline; margin: 0 6px 0 0; }
        .badge { padding: 2px 8px; border-radius: 999px; border:1px solid var(--border); font-size: 12px; color: var(--muted); }
        .badge.ok { color: #6de39b; border-color: #1f3a2b; background: #0e1f16; }
        .note { font-size: 12px; color: var(--muted); }
        .footerbar { position: fixed; left: 0; right: 0; bottom: 0; background: transparent; border-top: 1px solid var(--border); }
        .footer-inner { display: grid; grid-template-columns: 1fr 1fr 1fr; align-items: center; gap: 16px; padding-top: 12px; padding-bottom: 12px; }
        .footer-col.left { justify-self: start; display: flex; gap: 8px; align-items: center; }
        .footer-col.center { justify-self: center; }
        .footer-col.right { justify-self: end; display: flex; gap: 8px; align-items: center; }
        .chip { font-size: 12px; padding: 2px 8px; border-radius: 999px; border:1px solid var(--border); color: var(--muted); }
        .chip.prod { color:#6de39b; border-color:#1f3a2b; background:#0e1f16; }
        .grid-3 { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 16px; }
        .toggle { display:inline-flex; align-items:center; gap:8px; font-size: 13px; color: var(--text); }
        .switch { position: relative; width: 36px; height: 22px; background: #1b2230; border:1px solid var(--border); border-radius: 999px; cursor: pointer; transition: background .2s ease; }
        .switch::after { content: ""; position: absolute; top: 50%; left: 3px; transform: translateY(-50%); width: 16px; height: 16px; background: #8892a6; border-radius: 50%; transition: left .2s ease, background .2s ease; }
        .switch.on { background: #183055; border-color: #2a4f8e; }
        .switch.on::after { left: 17px; background: #4f8cff; }
        .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
        .panel-footer { display:flex; justify-content:flex-end; align-items:center; margin-top: auto; padding-top: 12px; gap: 8px; }
        .panel-footer.column-footer { flex-direction: column; align-items: flex-end; }
        .panel-footer.column-footer { align-items: flex-start; }
        .panel-footer.column-footer .toolbar { justify-content: flex-start; }
        /* New layout */
        .app { display:flex; flex-direction: column; gap: 24px; align-items: stretch; }
        .sidebar { flex: 0 0 auto; max-width: 100%; position: static; top: auto; height: auto; }
        .sidebar .panel > div:not(.panel-footer) { margin-top: 18px; }
        .content { flex: 0 0 auto; max-width: 100%; display: flex; flex-direction: column; gap: 24px; align-items: stretch; }
        .content > .section.panel { width: 100%; flex: 0 0 auto; margin: 0; }
        .section.panel table { width: 100%; }
        /* Narrow select and index columns */
        .section.panel table th:first-child,
        .section.panel table td:first-child { width: 36px; max-width: 36px; text-align: center; padding-left: 8px; padding-right: 8px; }
        .section.panel table th:nth-child(2),
        .section.panel table td:nth-child(2) { width: 48px; max-width: 48px; text-align: right; padding-left: 8px; padding-right: 8px; }
        .toolbar { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
        .toolbar .status, .toolbar .progress { margin-top: 0; }
        .stack { display:flex; flex-direction:column; gap:8px; }
        .sidebar .toolbar { justify-content:flex-start; }
        .ghost { opacity: .6; pointer-events: none; }
        /* Hide filters panel in sidebar until opened in modal */
        #filters-section { display: none !important; }
        /* Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.6); display: none; align-items: center; justify-content: center; z-index: 1000; pointer-events: none; }
        .modal-overlay.open { display: flex; pointer-events: auto; }
        .modal-overlay[hidden] { display: none !important; }
        .modal { position: relative; background: var(--panel); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); display: flex; flex-direction: column; max-width: 90%; max-height: 90%; overflow: hidden; }
        .modal:not(.compact) { height: 90vh; max-height: 90vh; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { margin: 0; }
        .modal-body { flex: 1; overflow-y: auto; padding: 16px; }
        .modal-footer { display:flex; justify-content:flex-end; gap:8px; padding: 10px 16px; border-top: 1px solid var(--border); }
        .modal.compact { width: min(720px, 92vw); height: auto; max-height: 80vh; }
        .modal.compact .modal-body { flex: 0 0 auto; padding: 16px; }
        /* md-dialog sizing per M3 patterns */
        md-dialog::part(container) { background: var(--panel); border: 1px solid var(--border); }
        /* Medium (wider) container for filters */
        md-dialog.medium::part(container) {
          width: 1200px !important;
          max-width: 98vw !important;
          inline-size: 1200px !important;
          max-inline-size: 98vw !important;
          max-height: 94vh !important;
          height: auto !important;
        }
        /* Wide container for results */
        md-dialog.wide::part(container) {
          width: 1440px !important;
          max-width: 98vw !important;
          inline-size: 1440px !important;
          max-inline-size: 98vw !important;
          height: 90vh !important;
          max-height: 90vh !important;
        }
        .chipset { display:flex; gap:6px; flex-wrap: wrap; margin-top: 6px; }
        .chipset .chip { border-color: var(--border); }
    </style>
</head>
<body>
  <div class="container">
  <h1>UserVoice feedback extractor for Adobe Express
  </h1>
  <div class="intro">Find relevant feedback and verbatim quotes from the Adobe Express UserVoice in minutes—not hours. Set your criteria, find threads, then drill into matching comments.</div>
  <div class="hint" style="margin-bottom:12px;">How it works: 1) Set criteria 2) Find threads 3) Find comments.</div>

  <div class="app">
    <aside class="sidebar" id="sidebar-panel">
      <template id="filters-template">
        <div id="filters-section" class="panel filters">
          <div>
            <md-outlined-text-field id="optionalKeywords" label="Optional keywords (comma separated)" supporting-text="Any of these helps (broad)" style="width:100%" placeholder="e.g. pdf, export, caption"></md-outlined-text-field>
          </div>
          <div style="margin-top:12px;">
            <md-outlined-text-field id="mustKeywords" label="Must-have keywords (comma separated)" supporting-text="All of these should be present (strict)" style="width:100%" placeholder="e.g. brand kit, styles, logo"></md-outlined-text-field>
          </div>
          <div style="margin-top:12px;">
            <md-outlined-text-field id="excludeKeywords" label="Excluded keywords (comma separated)" supporting-text="Items containing any will be excluded" style="width:100%" placeholder="e.g. animation, video"></md-outlined-text-field>
          </div>
          <div style="margin-top:8px;">
            <div class="toggle" title="Adds domain synonyms (e.g., 'brand kit' → 'brand assets'). Increases recall."><md-switch id="useSynonyms" selected></md-switch><span>Expand with synonyms</span></div>
          </div>
          <div style="margin-top:12px;">
            <md-outlined-text-field id="featureDef" label="Feature definition (1-3 sentences)" supporting-text="Used for semantic matching" type="textarea" rows="3" style="width:100%" placeholder="Describe the functionality/flow you care about..."></md-outlined-text-field>
          </div>
          <div style="margin-top:8px;">
            <div class="toggle" title="Uses embeddings to find semantically similar content; slower but more precise."><md-switch id="useSemantic"></md-switch><span>Use semantic matching</span></div>
          </div>
          <div class="toolbar" style="justify-content: space-between; margin-top: 10px;">
            <span id="last-run" class="hint"></span>
          </div>
        </div>
      </template>
      <div class="stack" style="margin: 8px 0 0 0;">
        <div class="toolbar">
          <md-filled-button id="btn-configure-filters">Set search criteria</md-filled-button>
        </div>
        <div class="toolbar">
          <md-filled-button id="btn-parse">Find relevant threads</md-filled-button>
          <span id="parse-progress" class="progress"></span>
          <span id="parse-status" class="status"></span>
          <span id="parse-loader" class="loader">⏳</span>
          <a id="reopen-threads" class="hint" href="#" style="display:none;">Reopen results</a>
          <span id="last-run-threads" class="hint"></span>
        </div>
        <div class="toolbar">
          <md-filled-button id="btn-extract" disabled>Find matching comments</md-filled-button>
          <span id="comments-progress" class="progress"></span>
          <span id="comments-status" class="status"></span>
          <span id="comments-loader" class="loader">⏳</span>
          <span id="last-run-comments" class="hint"></span>
        </div>
      </div>
    </aside>

    <main class="content" style="display:none;">
      <div id="threads-section" class="section panel" aria-label="Relevant threads results" style="min-height:70vh;">
        <div class="toolbar" style="justify-content: space-between;">
          <h2>Relevant Threads <span id="selected-count" class="hint"></span></h2>
          <div class="toolbar">
            <md-outlined-button id="btn-export-threads-csv">Export CSV</md-outlined-button>
            <md-outlined-button id="btn-export-threads-xlsx">Export XLSX</md-outlined-button>
          </div>
        </div>
        <div id="filters-summary-threads" class="chipset" aria-live="polite"></div>
        <table>
          <caption class="sr-only">Relevant threads table</caption>
          <thead>
            <tr><th><input id="select-all" type="checkbox"/></th><th>#</th><th>Title</th><th>URL</th><th>Why</th></tr>
          </thead>
          <tbody id="threads-body" aria-live="polite"><tr id="threads-empty"><td colspan="5" class="hint">No threads yet. Click “Find relevant threads”.</td></tr></tbody>
        </table>
      </div>

      <div id="comments-section" class="section panel" aria-label="Matching comments results" style="min-height:70vh;">
        <div class="toolbar" style="justify-content: space-between;">
          <h2>User comments</h2>
          <div class="toolbar">
            <md-outlined-button id="btn-export-comments-csv">Export CSV</md-outlined-button>
            <md-outlined-button id="btn-export-comments-xlsx">Export XLSX</md-outlined-button>
            <span id="comments-selected-count" class="hint"></span>
            <md-outlined-button id="btn-copy-selected" disabled>Copy selected</md-outlined-button>
            <md-outlined-button id="btn-export-selected-csv" disabled>Export selected CSV</md-outlined-button>
            <md-outlined-button id="btn-export-selected-xlsx" disabled>Export selected XLSX</md-outlined-button>
          </div>
        </div>
        <div id="filters-summary-comments" class="chipset" aria-live="polite"></div>
        <table>
          <caption class="sr-only">Matching comments table</caption>
          <thead>
           <tr><th><input id="select-all-comments" type="checkbox"/></th><th>#</th><th>Title</th><th>URL</th><th>Why</th></tr>
          </thead>
         <tbody id="comments-body" aria-live="polite"><tr id="comments-empty"><td colspan="5" class="hint">No comments yet. Click “Find matching comments”.</td></tr></tbody>
        </table>
      </div>
    </main>
    <md-dialog id="app-dialog" class="medium">
      <div class="toolbar" id="modal-head" slot="headline" style="justify-content: space-between; gap: 12px; align-items: center;">
        <h2 id="modal-title" style="margin:0;">Results</h2>
        <div class="toolbar" id="modal-progress-wrap">
          <span id="modal-progress" class="progress"></span>
          <span id="modal-status" class="status"></span>
          <span id="modal-loader" class="loader">⏳</span>
          <md-outlined-button id="modal-close">Close</md-outlined-button>
        </div>
      </div>
      <div id="modal-body" class="modal-body" slot="content" style="padding-bottom: 0;"></div>
      <div id="modal-footer" class="modal-footer" slot="actions" style="display:none;">
        <span id="filters-error" class="status error" style="min-height:18px; margin-right:auto;"></span>
        <md-outlined-button id="btn-clear-filters">Clear</md-outlined-button>
        <md-filled-button id="btn-save-filters">Save</md-filled-button>
      </div>
    </md-dialog>
  </div>

  <div class="footerbar">
    <div class="container footer-inner">
      <div class="footer-col left">
        <span style="color: var(--muted); font-size: 13px;">Sign in status</span>
        <span id="auth-status" class="badge">Checking auth...</span>
      </div>
      <div class="footer-col center">
        <a href="https://adobeexpress.uservoice.com/forums/951181-adobe-express" target="_blank" rel="noopener">Adobe Express Uservoice Forum</a>
      </div>
      <div class="footer-col right">
        <span id="env-chip" class="chip">env</span>
        <span id="backend-chip" class="chip">backend</span>
        <a id="logs-link" class="chip" href="#" target="_blank" rel="noopener" style="display:none;">Logs</a>
      </div>
    </div>
  </div>

  <div id="sr-announce" class="sr-announcer" aria-live="polite"></div>

  <script type="module">
    import 'https://unpkg.com/@material/web@latest/button/filled-button.js?module';
    import 'https://unpkg.com/@material/web@latest/button/outlined-button.js?module';
    import 'https://unpkg.com/@material/web@latest/textfield/outlined-text-field.js?module';
    import 'https://unpkg.com/@material/web@latest/switch/switch.js?module';
    import 'https://unpkg.com/@material/web@latest/dialog/dialog.js?module';
    // Note: Dialog kept custom for now; consider md-dialog in a later step
    const el = (id) => document.getElementById(id);
    let relevantThreads = [];
    let selectedThreads = new Set();
    let threadRowCount = 0;
    let commentRowCount = 0;
    let selectedComments = new Set();
    let isAuthed = false;
    let sseParse = null;
    let sseComments = null;
    let parseJobState = 'idle';
    let parseLastKey = '';
    let commentsJobState = 'idle';
    let commentsLastKey = '';

    // Production chip and backend info
    (function setEnvChips(){
      const isProd = window.location.hostname !== 'localhost';
      const envChip = el('env-chip');
      const backendChip = el('backend-chip');
      const logsLink = el('logs-link');
      envChip.textContent = isProd ? 'production' : 'local';
      if (isProd) envChip.className = 'chip prod';
      backendChip.textContent = window.location.origin;
      if (/onrender\.com$/.test(window.location.hostname)) {
        logsLink.href = window.location.origin + '/health';
        logsLink.style.display = 'inline-block';
        logsLink.textContent = 'Health';
      }
    })();

    // Note: No migration that alters user-entered values

    async function refreshAuth() {
      try {
        const res = await fetch('/auth/status');
        const data = await res.json();
        const hasCookieAuth = !!data.authenticated;
        const hasOAuth = !!data.oauth;
        isAuthed = hasCookieAuth || hasOAuth;
        el('auth-status').textContent = hasCookieAuth ? 'Signed in' : (hasOAuth ? 'API auth' : 'Not signed in');
        el('auth-status').className = isAuthed ? 'badge ok' : 'badge';
      } catch (_) {
        el('auth-status').textContent = 'Unknown';
        el('auth-status').className = 'badge';
      }
    }

    function csvToArray(value) { return (value || '').split(',').map(s => s.trim()).filter(Boolean); }

    function loadFilters() {
      try {
        const raw = localStorage.getItem('uv_filters');
        if (!raw) { updateFiltersSummary(); updateButtonsEnabled(); return; }
        const f = JSON.parse(raw);
        const optEl = el('optionalKeywords'); if (optEl && f.optional != null) optEl.value = f.optional;
        const mustEl = el('mustKeywords'); if (mustEl && f.must != null) mustEl.value = f.must;
        const excEl = el('excludeKeywords'); if (excEl && f.exclude != null) excEl.value = f.exclude;
        const featEl = el('featureDef'); if (featEl && f.featureDef != null) featEl.value = f.featureDef;
        const synEl = document.getElementById('useSynonyms'); if (synEl && f.useSynonyms != null) { if ('selected' in synEl) synEl.selected = !!f.useSynonyms; else synEl.checked = !!f.useSynonyms; }
        const semEl = document.getElementById('useSemantic'); if (semEl && f.useSemantic != null) { if ('selected' in semEl) semEl.selected = !!f.useSemantic; else semEl.checked = !!f.useSemantic; }
      } catch (_) {}
      updateFiltersSummary();
      updateButtonsEnabled();
    }

    function saveFilters() {
      const readField = (id) => {
        const host = document.getElementById(id);
        let v = host?.value;
        if (!v && host && host.querySelector) { const n = host.querySelector('input, textarea'); if (n) v = n.value; }
        if (typeof v !== 'string') v = '';
        v = v.trim();
        return v;
      };
      const payload = {
        optional: readField('optionalKeywords'),
        must: readField('mustKeywords'),
        exclude: readField('excludeKeywords'),
        featureDef: readField('featureDef'),
        useSynonyms: !!(document.getElementById('useSynonyms')?.selected),
        useSemantic: !!(document.getElementById('useSemantic')?.selected),
      };
      localStorage.setItem('uv_filters', JSON.stringify(payload));
      updateFiltersSummary();
      updateButtonsEnabled();
    }

    function readFiltersFromDOMOrStorage(){
      const getVal = (id) => {
        const host = document.getElementById(id);
        if (host) {
          let v = host.value;
          if (!v && host.querySelector) { const n = host.querySelector('input, textarea'); if (n) v = n.value; }
          if (typeof v === 'string') { const t = v.trim(); return t; }
        }
        const store = JSON.parse(localStorage.getItem('uv_filters') || '{}');
        const key = id==='featureDef'?'featureDef':(id==='mustKeywords'?'must':id==='optionalKeywords'?'optional':id==='excludeKeywords'?'exclude':id);
        const val = (store[key] || '').trim();
        return val;
      };
      const getBool = (id, key) => {
        const el = document.getElementById(id);
        if (el && 'selected' in el) return !!el.selected;
        const f = JSON.parse(localStorage.getItem('uv_filters')||'{}');
        return !!f[key];
      };
      return {
        must: csvToArray(getVal('mustKeywords')),
        optional: csvToArray(getVal('optionalKeywords')),
        exclude: csvToArray(getVal('excludeKeywords')),
        featureDef: String(getVal('featureDef')).trim(),
        useSynonyms: getBool('useSynonyms','useSynonyms'),
        useSemantic: getBool('useSemantic','useSemantic')
      };
    }

    function buildQueryPayload() {
      const q = readFiltersFromDOMOrStorage();
      return { cookie: '', query: q };
    }

    function computeKey(obj) { try { return JSON.stringify(obj); } catch(_) { return String(obj); } }

    function updateFiltersSummary() {
      const wrapThreads = el('filters-summary-threads');
      const wrapComments = el('filters-summary-comments');
      if (!wrapThreads && !wrapComments) return;
      const q = readFiltersFromDOMOrStorage();
      const must = q.must;
      const opt = q.optional;
      const exc = q.exclude;
      const feat = q.featureDef || '';
      [wrapThreads, wrapComments].forEach(wrap=>{ if (!wrap) return; wrap.innerHTML = ''; });
      const mk = (label, arrOrStr) => {
        const val = Array.isArray(arrOrStr) ? arrOrStr.join(', ') : arrOrStr;
        if (!val) return null;
        const span = document.createElement('span'); span.className = 'chip'; span.textContent = label + ': ' + val; return span;
      };
      const chips = [mk('Must', must), mk('Optional', opt), mk('Exclude', exc), mk('Feature', feat)].filter(Boolean);
      [wrapThreads, wrapComments].forEach(wrap=>{ if (!wrap) return; chips.forEach(x => wrap.appendChild(x.cloneNode(true))); });
    }

    function hasSearchCriteria(){
      const q = readFiltersFromDOMOrStorage();
      return q.must.length > 0 || q.optional.length > 0 || q.featureDef.length > 0;
    }

    function updateButtonsEnabled(){
      const parseBtn = el('btn-parse');
      if (parseBtn) parseBtn.disabled = (!hasSearchCriteria() && parseJobState !== 'running');
    }

    function announce(msg) { /* no-op; remove screen reader announcements */ }

    // Modal refs and helpers
    const mdDialog = document.getElementById('app-dialog');
    const modalRoot = mdDialog; // alias for compatibility
    const modalTitle = el('modal-title');
    const modalBody = el('modal-body');
    const modalFooter = el('modal-footer');
    const modalClose = el('modal-close');
    let modalCurrent = null; // 'threads' | 'comments' | 'filters' | null

    function openModalWith(sectionId, title) {
      modalTitle.textContent = title;
      if (sectionId === 'filters-section') {
        mdDialog?.classList.remove('full');
        mdDialog?.classList.remove('wide');
        mdDialog?.classList.add('medium');
        modalCurrent = 'filters';
        if (modalRoot) modalRoot.classList.add('compact');
        if (modalFooter) modalFooter.style.display = 'flex';
        modalBody.innerHTML = '';
        // Render fresh instance from template so filters never appear on page
        const tpl = document.getElementById('filters-template');
        if (tpl && tpl.content) {
          const frag = tpl.content.cloneNode(true);
          const sec = frag.querySelector('#filters-section');
          if (sec) { while (sec.firstChild) modalBody.appendChild(sec.firstChild); }
          else { modalBody.appendChild(frag); }
          // Hydrate values from storage
          try { const raw = localStorage.getItem('uv_filters'); if (raw) { const f = JSON.parse(raw); const setV=(id,v)=>{ const host=document.getElementById(id); if (!host) return; if ('value' in host && host.value !== undefined) host.value=v||''; const inner = host.querySelector && host.querySelector('input, textarea'); if (inner) inner.value=v||''; }; setV('optionalKeywords', f.optional||''); setV('mustKeywords', f.must||''); setV('excludeKeywords', f.exclude||''); setV('featureDef', f.featureDef||''); const syn=document.getElementById('useSynonyms'); if (syn) syn.selected=!!f.useSynonyms; const sem=document.getElementById('useSemantic'); if (sem) sem.selected=!!f.useSemantic; } } catch(_) {}
          // Bind listeners for this instance
          ['optionalKeywords','mustKeywords','excludeKeywords','featureDef'].forEach(id=>{ const e = document.getElementById(id); if (!e) return; e.addEventListener('input', () => saveFilters()); });
        }
        const ferr = document.getElementById('filters-error'); if (ferr) ferr.textContent = '';
      } else {
        mdDialog?.classList.remove('medium');
        mdDialog?.classList.add('wide');
        modalCurrent = sectionId === 'threads-section' ? 'threads' : 'comments';
        if (modalRoot) modalRoot.classList.remove('compact');
        if (modalFooter) modalFooter.style.display = 'none';
        modalBody.innerHTML = '';
        const section = document.getElementById(sectionId);
        if (section) modalBody.appendChild(section);
      }
      try { if (mdDialog && typeof mdDialog.show === 'function') { mdDialog.show(); } else if (mdDialog) { mdDialog.open = true; } } catch(_) { if (mdDialog) mdDialog.open = true; }
    }

    function closeModal() {
      const content = document.querySelector('main.content');
      const threadsSec = document.getElementById('threads-section');
      const commentsSec = document.getElementById('comments-section');
      if (content && threadsSec && !content.contains(threadsSec)) content.appendChild(threadsSec);
      if (content && commentsSec && !content.contains(commentsSec)) content.appendChild(commentsSec);
      if (modalCurrent === 'filters') { modalBody.innerHTML = ''; }
      try { if (mdDialog && typeof mdDialog.close === 'function') { mdDialog.close(); } else if (mdDialog) { mdDialog.open = false; } } catch(_) { if (mdDialog) mdDialog.open = false; }
      modalCurrent = null;
    }
    if (modalClose) modalClose.addEventListener('click', closeModal);
    mdDialog?.addEventListener('closed', ()=>{ modalCurrent=null; });

    // Focus trap & keyboard shortcuts
    let lastFocused = null;
    function trapFocusOpen(){ lastFocused = document.activeElement; modalRoot?.focus?.(); document.addEventListener('keydown', onKeydownGlobal); }
    function trapFocusClose(){ document.removeEventListener('keydown', onKeydownGlobal); if (lastFocused && lastFocused.focus) lastFocused.focus(); }
    function onKeydownGlobal(e){
      if (e.key === 'Escape') { e.preventDefault(); closeModal(); return; }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'k') { e.preventDefault(); openFiltersModal(); }
      if (mdDialog && (mdDialog.open || mdDialog.hasAttribute && mdDialog.hasAttribute('open')) && e.key === 'Tab') {
        const focusables = modalRoot.querySelectorAll('button, [href], input, textarea, [tabindex]:not([tabindex="-1"])');
        if (!focusables.length) return; const first = focusables[0]; const last = focusables[focusables.length - 1];
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
    }

    function clearThreads() {
      el('threads-body').innerHTML = '<tr id="threads-empty"><td colspan="5" class="hint">No threads yet. Click “Find relevant threads”.</td></tr>';
      relevantThreads = []; selectedThreads.clear(); threadRowCount = 0; updateExtractButtons();
    }

    function clearComments() {
      el('comments-body').innerHTML = '<tr id="comments-empty"><td colspan="5" class="hint">No comments yet. Click “Find matching comments”.</td></tr>';
      commentRowCount = 0; selectedComments.clear(); updateSelectedCommentsUI();
    }

    function renderThread(row) {
      const empty = el('threads-empty'); if (empty) empty.remove();
      const tr = document.createElement('tr');
      tr.dataset.threadUrl = row.url;
      const tdSel = document.createElement('td');
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.addEventListener('change', () => {
        if (cb.checked) selectedThreads.add(row.url); else selectedThreads.delete(row.url);
        updateSelectionUI();
      });
      tdSel.appendChild(cb);
      const tdIdx = document.createElement('td');
      const tdTitle = document.createElement('td');
      const tdUrl = document.createElement('td');
      const tdWhy = document.createElement('td');
      tdIdx.textContent = String(++threadRowCount);
      tdTitle.textContent = row.title;
      const a = document.createElement('a');
      a.href = row.url; a.target = '_blank'; a.rel = 'noopener'; a.textContent = 'Thread URL';
      tdUrl.appendChild(a);
      tdWhy.appendChild(formatWhy(row._why));
      tr.appendChild(tdSel); tr.appendChild(tdIdx); tr.appendChild(tdTitle); tr.appendChild(tdUrl); tr.appendChild(tdWhy);
      el('threads-body').appendChild(tr);
      updateExtractButtons();
      announce('Thread added: ' + row.title);
    }

    function updateSelectionUI() {
      const count = selectedThreads.size;
      const badge = document.getElementById('selected-count');
      if (badge) badge.textContent = count ? '(' + count + ' selected)' : '';
    }

    function updateExtractButtons(){
      const btn = el('btn-extract');
      if (!btn) return;
      btn.disabled = relevantThreads.length === 0;
    }

    function markThreadNote(threadUrl, note) {
      const rows = el('threads-body').querySelectorAll('tr');
      for (const r of rows) {
        if (r.dataset.threadUrl === threadUrl) {
          let cell = r.querySelector('td.note-cell');
          if (!cell) { cell = document.createElement('td'); cell.className = 'note-cell'; r.appendChild(cell); }
          cell.textContent = note; cell.className = 'note-cell note'; break;
        }
      }
    }

    function renderComment(row) {
      const empty = el('comments-empty'); if (empty) empty.remove();
      const tr = document.createElement('tr');
      tr.dataset.threadUrl = row.threadUrl || row.url;
      const cid = 'c-' + (commentRowCount + 1);
      tr.dataset.commentId = cid;
      const tdSel = document.createElement('td');
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.addEventListener('change', () => { if (cb.checked) selectedComments.add(cid); else selectedComments.delete(cid); updateSelectedCommentsUI(); });
      tdSel.appendChild(cb);
      const tdIdx = document.createElement('td'); tdIdx.textContent = String(++commentRowCount);
      const tdTitle = document.createElement('td'); tdTitle.textContent = row.body;
      const tdUrl = document.createElement('td'); const a = document.createElement('a'); a.href = row.threadUrl || row.url; a.target = '_blank'; a.rel = 'noopener'; a.textContent = 'Thread URL'; tdUrl.appendChild(a);
      const tdWhy = document.createElement('td'); tdWhy.appendChild(formatWhy(row._why));
      tr.appendChild(tdSel); tr.appendChild(tdIdx); tr.appendChild(tdTitle); tr.appendChild(tdUrl); tr.appendChild(tdWhy);
      el('comments-body').appendChild(tr);
      announce('Comment added');
    }

    function updateSelectedCommentsUI(){
      const countEl = el('comments-selected-count'); const c = selectedComments.size; if (countEl) countEl.textContent = c ? `Selected: ${c}` : '';
      const btnCopy = el('btn-copy-selected'); const btnCsv = el('btn-export-selected-csv'); const btnX = el('btn-export-selected-xlsx');
      [btnCopy, btnCsv, btnX].forEach(b=>{ if (!b) return; b.disabled = c === 0; });
    }

    function formatWhy(text) {
      const container = document.createElement('div'); container.className = 'why'; if (!text) return container;
      const tokens = String(text).split(/[;|,\n]+/).map(t=>t.trim()).filter(Boolean);
      tokens.forEach(tok => {
        const m = /^([^:]+):\s*(.+)$/.exec(tok); let label = '', value = '';
        if (m) { label = m[1].toLowerCase(); value = m[2]; } else { value = tok; }
        const span = document.createElement('span'); span.className = 'chip';
        if (/must/.test(label)) span.classList.add('must');
        else if (/optional|syn/.test(label)) span.classList.add('optional');
        else if (/exclude|not/.test(label)) span.classList.add('exclude');
        else if (/prox|near|distance/.test(label)) span.classList.add('prox');
        else if (/sem|embedding|cosine|score/.test(label)) span.classList.add('sem');
        span.textContent = m ? `${label}: ${value}` : value; container.appendChild(span);
      });
      return container;
    }

    function setLastRun(kind, info) {
      const t = new Date().toLocaleTimeString();
      if (kind === 'threads') el('last-run-threads').textContent = `Last run: ${t}`;
      else el('last-run-comments').textContent = `Last run: ${t}`;
      el('last-run').textContent = (kind === 'threads') ? `Last threads run: ${t} (${info})` : `Last comments run: ${t} (${info})`;
      const linkThreads = el('reopen-threads'); const linkComments = el('reopen-comments');
      if (linkThreads) linkThreads.style.display = (kind === 'threads') ? 'inline' : 'none';
      if (linkComments) linkComments.style.display = (kind === 'comments') ? 'inline' : 'none';
    }

    async function startParse() {
      const payload = buildQueryPayload();
      const currentKey = computeKey(payload.query);
      if ((parseJobState === 'running' || parseJobState === 'completed') && parseLastKey === currentKey) {
        modalCurrent = 'threads'; openModalWith('threads-section', 'Relevant Threads'); return;
      }
      if (!isAuthed) { el('parse-status').textContent = 'Please sign in'; el('parse-status').className = 'status error'; return; }
      const hasAny = (payload.query.must.length + payload.query.optional.length) > 0 || payload.query.featureDef.length > 0;
      if (!hasAny) { el('parse-status').textContent = 'Provide at least one keyword or a feature definition'; el('parse-status').className = 'status error'; return; }
      clearThreads(); el('parse-status').textContent = ''; el('parse-progress').textContent = ''; if (modalStatus) modalStatus.textContent = ''; if (modalProgress) modalProgress.textContent = '';
      modalCurrent = 'threads'; openModalWith('threads-section', 'Relevant Threads'); el('parse-loader').style.display = 'inline'; if (modalLoader) modalLoader.style.display = 'inline';
      try {
        parseJobState = 'running'; parseLastKey = currentKey;
        const res = await fetch('/api/parse/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const { jobId, error } = await res.json(); if (!res.ok) throw new Error(error || 'Failed to start parse job');
        if (sseParse) { try { sseParse.close(); } catch(_){} }
        sseParse = new EventSource(`/api/parse/events/${jobId}`);
        sseParse.addEventListener('connected', () => { el('parse-status').textContent = 'Connected'; el('parse-status').className = 'status'; });
        sseParse.addEventListener('thread', (ev) => { const row = JSON.parse(ev.data); relevantThreads.push(row); renderThread(row); updateSelectionUI(); });
        sseParse.addEventListener('progress', (ev) => {
          const p = JSON.parse(ev.data);
          if (p.phase === 'discover') { el('parse-progress').textContent = `Pages discovered: ${p.discoveredPages || p.pageIndex}`; if (modalCurrent === 'threads' && modalProgress) modalProgress.textContent = el('parse-progress').textContent; return; }
          const scanned = p.scannedThreads || 0; const total = p.totalThreads || 0; const rel = p.totalRelevant || 0;
          el('parse-progress').textContent = `Threads scanned: ${scanned}/${total} | Relevant: ${rel}`; if (modalCurrent === 'threads' && modalProgress) modalProgress.textContent = el('parse-progress').textContent;
        });
        sseParse.addEventListener('error', (ev) => { const msg = JSON.parse(ev.data).message; parseJobState = 'error'; el('parse-status').textContent = msg; el('parse-status').className = 'status error'; if (modalCurrent === 'threads' && modalStatus) modalStatus.textContent = msg; sseParse.close(); el('parse-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; });
        sseParse.addEventListener('done', () => { parseJobState = 'completed'; el('parse-status').textContent = 'Completed'; el('parse-status').className = 'status'; if (modalCurrent === 'threads' && modalStatus) modalStatus.textContent = 'Completed'; sseParse.close(); el('parse-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; setLastRun('threads', `${relevantThreads.length} found`); });
      } catch (e) { el('parse-status').textContent = e.message; el('parse-status').className = 'status error'; el('parse-loader').style.display = 'none'; }
    }

    async function startExtract() {
      const payload = buildQueryPayload(); if (!isAuthed) { el('comments-status').textContent = 'Please sign in'; el('comments-status').className = 'status error'; return; }
      const threadsToUse = (selectedThreads.size ? relevantThreads.filter(t => selectedThreads.has(t.url)) : relevantThreads);
      const commentsKey = computeKey({ query: payload.query, threads: threadsToUse.map(t => t.id || t.url) });
      if ((commentsJobState === 'running' || commentsJobState === 'completed') && commentsLastKey === commentsKey) { modalCurrent = 'comments'; openModalWith('comments-section', 'User comments'); return; }
      if (threadsToUse.length === 0) { el('comments-status').textContent = 'Select threads or run extraction first'; el('comments-status').className = 'status error'; return; }
      clearComments(); el('comments-status').textContent = ''; el('comments-progress').textContent = ''; if (modalStatus) modalStatus.textContent = ''; if (modalProgress) modalProgress.textContent = '';
      modalCurrent = 'comments'; openModalWith('comments-section', 'User comments'); el('comments-loader').style.display = 'inline'; if (modalLoader) modalLoader.style.display = 'inline';
      try {
        commentsJobState = 'running'; commentsLastKey = commentsKey;
        const res = await fetch('/api/comments/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ...payload, threads: threadsToUse }) });
        const { jobId, error } = await res.json(); if (!res.ok) throw new Error(error || 'Failed to start comments job');
        if (sseComments) { try { sseComments.close(); } catch(_){} }
        sseComments = new EventSource(`/api/comments/events/${jobId}`);
        sseComments.addEventListener('connected', () => { el('comments-status').textContent = 'Connected'; el('comments-status').className = 'status'; if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = 'Connected'; });
        sseComments.addEventListener('comment', (ev) => { const row = JSON.parse(ev.data); renderComment(row); });
        sseComments.addEventListener('threadNoComments', (ev) => { const d = JSON.parse(ev.data); markThreadNote(d.threadUrl, 'No comments'); });
        sseComments.addEventListener('threadNoMatches', (ev) => { const d = JSON.parse(ev.data); markThreadNote(d.threadUrl, 'No matches'); });
        sseComments.addEventListener('progress', (ev) => { const p = JSON.parse(ev.data); const txt = `Threads processed: ${p.threadIndex || 0} | Relevant: ${p.totalRelevant || 0}`; el('comments-progress').textContent = txt; if (modalCurrent === 'comments' && modalProgress) modalProgress.textContent = txt; });
        sseComments.addEventListener('error', (ev) => { const msg = JSON.parse(ev.data).message; commentsJobState = 'error'; el('comments-status').textContent = msg; el('comments-status').className = 'status error'; if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = msg; sseComments.close(); el('comments-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; });
        sseComments.addEventListener('done', () => { commentsJobState = 'completed'; el('comments-status').textContent = 'Completed'; el('comments-status').className = 'status'; if (modalCurrent === 'comments' && modalStatus) modalStatus.textContent = 'Completed'; sseComments.close(); el('comments-loader').style.display = 'none'; if (modalLoader) modalLoader.style.display = 'none'; setLastRun('comments', `${el('comments-body').children.length} added`); });
      } catch (e) { el('comments-status').textContent = e.message; el('comments-status').className = 'status error'; el('comments-loader').style.display = 'none'; }
    }

    function stopComments() { if (sseComments) { try { sseComments.close(); } catch(_){} } el('comments-status').textContent = 'Stopped'; }

    // Exports (unchanged)
    let xlsxLoading = null;
    function loadScript(src) { return new Promise((resolve, reject) => { const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>resolve(); s.onerror=()=>reject(new Error('Failed to load '+src)); document.head.appendChild(s); }); }
    async function ensureXLSX() {
      if (window.XLSX) return; if (!xlsxLoading) { const fallbacks = ['/vendor/xlsx.full.min.js','https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js','https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js','https://cdn.sheetjs.com/xlsx-0.18.5/package/dist/xlsx.full.min.js']; xlsxLoading = (async () => { for (const url of fallbacks) { try { await loadScript(url); if (window.XLSX) return; } catch(_) {} } if (!window.XLSX) throw new Error('XLSX library failed to load'); })(); }
      return xlsxLoading;
    }
    function exportThreadsCSV() { if (!relevantThreads.length) return; const rows = [['#','Title','URL','Why']]; relevantThreads.forEach((t,i)=>rows.push([i+1,t.title,t.url,t._why||''])); downloadCSV(rows, 'threads.csv'); }
    function exportCommentsCSV() { const rows = [['#','Title','URL','Why']]; const trs = Array.from(el('comments-body').children); trs.forEach(tr=>{ const tds = tr.querySelectorAll('td'); if (tds.length<5) return; const idx = tds[1].textContent || ''; const title = tds[2].textContent || ''; const linkEl = tds[3].querySelector('a'); const url = linkEl ? linkEl.href : ''; const why = tds[4].textContent || ''; rows.push([idx, title, url, why]); }); downloadCSV(rows, 'comments.csv'); }
    function downloadCSV(rows, filename){ const csv = rows.map(r=>r.map(v => '"'+String(v).replace(/"/g,'""')+'"').join(',')).join('\n'); const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href); }
    async function exportThreadsXLSX(){ if(!relevantThreads.length) return; try { await ensureXLSX(); } catch(e) { alert('Could not load XLSX export library.'); return; } const wb=XLSX.utils.book_new(); const data=[['#','Title','URL','Why']]; relevantThreads.forEach((t,i)=>data.push([i+1,t.title,t.url,t._why||''])); const ws=XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(wb,ws,'Threads'); XLSX.writeFile(wb,'threads.xlsx'); }
    async function exportCommentsXLSX(){ try { await ensureXLSX(); } catch(e) { alert('Could not load XLSX export library.'); return; } const wb=XLSX.utils.book_new(); const data=[['#','Title','URL','Why']]; const trs=Array.from(el('comments-body').children); trs.forEach(tr=>{const tds=tr.querySelectorAll('td'); if(tds.length<5)return; const idx=tds[1].textContent||''; const title=tds[2].textContent||''; const linkEl=tds[3].querySelector('a'); const url=linkEl?linkEl.href:''; const why=tds[4].textContent||''; data.push([idx,title,url,why]);}); const ws=XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(wb,ws,'Comments'); XLSX.writeFile(wb,'comments.xlsx'); }

    function syncLayoutHeights() { const sidebar = document.querySelector('.sidebar'); const content = document.querySelector('.content'); if (sidebar && content) { content.style.minHeight = sidebar.offsetHeight + 'px'; } }
    window.addEventListener('load', syncLayoutHeights); window.addEventListener('resize', syncLayoutHeights); setTimeout(syncLayoutHeights, 0);

    // Events
    // Material switches and text fields wiring
    const synInput = document.getElementById('useSynonyms');
    const semInput = document.getElementById('useSemantic');
    const tfIds = ['optionalKeywords','mustKeywords','excludeKeywords','featureDef'];
    // Load existing values into M3 components
    function setTfValue(id, value){ const eltf = document.getElementById(id); if (eltf) eltf.value = value ?? ''; }
    // After loadFilters hydrates values, ensure M3 fields reflect them
    const _origLoadFilters = loadFilters;
    loadFilters = function(){ _origLoadFilters(); try { const raw = localStorage.getItem('uv_filters'); if (raw) { const f = JSON.parse(raw); setTfValue('optionalKeywords', f.optional||''); setTfValue('mustKeywords', f.must||''); setTfValue('excludeKeywords', f.exclude||''); setTfValue('featureDef', f.featureDef||''); if (synInput) synInput.selected = !!f.useSynonyms; if (semInput) semInput.selected = !!f.useSemantic; } } catch(_) {} };

    ['optionalKeywords','mustKeywords','excludeKeywords','featureDef'].forEach(id=>{ const e = document.getElementById(id); if (!e) return; e.addEventListener('input', () => saveFilters()); });
    updateButtonsEnabled();

    el('select-all').addEventListener('change', (ev)=>{ const checked = ev.target.checked; const rows = el('threads-body').querySelectorAll('input[type="checkbox"]'); rows.forEach(cb=>{ cb.checked = checked; const tr = cb.closest('tr'); if (!tr) return; const url = tr.dataset.threadUrl; if (checked) selectedThreads.add(url); else selectedThreads.delete(url); }); updateSelectionUI(); });
    const selAllComments = el('select-all-comments'); if (selAllComments) selAllComments.addEventListener('change', (ev)=>{ const checked = ev.target.checked; const rows = el('comments-body').querySelectorAll('tr'); rows.forEach(tr=>{ const cb = tr.querySelector('input[type="checkbox"]'); if (!cb) return; cb.checked = checked; const cid = tr.dataset.commentId; if (!cid) return; if (checked) selectedComments.add(cid); else selectedComments.delete(cid); }); updateSelectedCommentsUI(); });

    el('btn-parse').addEventListener('click', startParse);
    el('btn-extract').addEventListener('click', startExtract);
    el('btn-export-threads-csv').addEventListener('click', exportThreadsCSV);
    el('btn-export-threads-xlsx').addEventListener('click', exportThreadsXLSX);
    el('btn-export-comments-csv').addEventListener('click', exportCommentsCSV);
    el('btn-export-comments-xlsx').addEventListener('click', exportCommentsXLSX);
    const btnCopySel = el('btn-copy-selected'); if (btnCopySel) btnCopySel.addEventListener('click', async ()=>{ const items = getSelectedCommentsRows(); if (!items.length) return; const text = items.map(i=>`"${i.body}" — ${i.threadTitle || 'Thread'} (${i.url})`).join('\n\n'); try { await navigator.clipboard.writeText(text); } catch(_) {} });
    const btnExpSelCsv = el('btn-export-selected-csv'); if (btnExpSelCsv) btnExpSelCsv.addEventListener('click', ()=>{ const items = getSelectedCommentsRows(); if (!items.length) return; const rows = [['Comment','Thread Title','Thread URL','Why']]; items.forEach(i=>rows.push([i.body,i.threadTitle||'',i.url,i.why||''])); downloadCSV(rows,'selected-comments.csv'); });
    const btnExpSelX = el('btn-export-selected-xlsx'); if (btnExpSelX) btnExpSelX.addEventListener('click', async ()=>{ const items = getSelectedCommentsRows(); if (!items.length) return; try { await ensureXLSX(); } catch(e) { alert('Could not load XLSX export library.'); return; } const wb=XLSX.utils.book_new(); const data=[['Comment','Thread Title','Thread URL','Why']]; items.forEach(i=>data.push([i.body,i.threadTitle||'',i.url,i.why||''])); const ws=XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(wb,ws,'Selected'); XLSX.writeFile(wb,'selected-comments.xlsx'); });

    function getSelectedCommentsRows(){
      const out = []; const rows = el('comments-body').querySelectorAll('tr');
      rows.forEach(tr=>{
        const cid = tr.dataset.commentId; if (!cid || !selectedComments.has(cid)) return; const tds = tr.querySelectorAll('td'); if (tds.length<5) return; const body = tds[2].textContent||''; const linkEl = tds[3].querySelector('a'); const url = linkEl?linkEl.href:''; const why = tds[4].textContent||''; let threadTitle = tr.dataset.threadTitle || ''; if (!threadTitle && url) { const mt = relevantThreads.find(t=>t.url===url); if (mt) threadTitle = mt.title; } out.push({ body, url, why, threadTitle });
      });
      return out;
    }

    loadFilters();
    refreshAuth();

    const btnConfigureFilters = document.getElementById('btn-configure-filters');
    function openFiltersModal(){ requestAnimationFrame(()=>openModalWith('filters-section', 'Configure search filters')); }
    window.openFiltersModal = openFiltersModal;
    if (btnConfigureFilters) btnConfigureFilters.addEventListener('click', openFiltersModal);
    // Extra safety: delegate click in case direct binding missed
    document.addEventListener('click', (e)=>{ const t = e.target && (e.target.id==='btn-configure-filters' ? e.target : e.target.closest && e.target.closest('#btn-configure-filters')); if (t) { e.preventDefault(); openFiltersModal(); } });

    const modalProgress = document.getElementById('modal-progress');
    const modalStatus = document.getElementById('modal-status');
    const modalLoader = document.getElementById('modal-loader');
    window.modalProgress = modalProgress; window.modalStatus = modalStatus; window.modalLoader = modalLoader;

    const btnSaveFilters = document.getElementById('btn-save-filters'); const filtersErrorEl = document.getElementById('filters-error');
    if (btnSaveFilters) btnSaveFilters.addEventListener('click', (e) => {
      e.preventDefault();
      const q = readFiltersFromDOMOrStorage();
      const hasAny = !!(q.optional.length || q.must.length || q.exclude.length || q.featureDef);
      if (!hasAny) { if (filtersErrorEl) filtersErrorEl.textContent = 'Provide at least one keyword or a feature definition'; return; }
      try { saveFilters(); } catch(_) {}
      if (filtersErrorEl) filtersErrorEl.textContent = '';
      closeModal();
    });
    const modalBodyEl = document.getElementById('modal-body'); if (modalBodyEl) modalBodyEl.addEventListener('keydown', (e) => { if (modalCurrent === 'filters' && e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'MD-OUTLINED-TEXT-FIELD')) { e.preventDefault(); const q = readFiltersFromDOMOrStorage(); const hasAny = !!(q.optional.length || q.must.length || q.exclude.length || q.featureDef); if (!hasAny) { const ferr = document.getElementById('filters-error'); if (ferr) ferr.textContent = 'Provide at least one keyword or a feature definition'; return; } btnSaveFilters?.click(); } });
    const btnClearFilters = document.getElementById('btn-clear-filters'); if (btnClearFilters) btnClearFilters.addEventListener('click', () => { ['optionalKeywords','mustKeywords','excludeKeywords','featureDef'].forEach(id=>{ const f=document.getElementById(id); if (f) f.value=''; }); const syn=document.getElementById('useSynonyms'); if (syn) syn.selected=true; const sem=document.getElementById('useSemantic'); if (sem) sem.selected=false; saveFilters(); updateFiltersSummary(); /* Keep parse button enabled if a parse job is running */ updateButtonsEnabled(); });

    const linkReopenThreads = el('reopen-threads'); if (linkReopenThreads) linkReopenThreads.addEventListener('click', (e)=>{ e.preventDefault(); modalCurrent='threads'; openModalWith('threads-section','Relevant Threads'); });
    
  </script>
</body>
</html>

